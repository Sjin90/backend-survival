## 1. Layered Architecture

A. 관심사의 분리 & Layered Architecture
    - 관심사의 분리 (Separation of Concerns)
        프로그램의 복잡도가 올라갈수록 관련된 내용들을 구별하여 부분으로 분리시키는 원리로 분리된 부분들은 각각의 관심사(도메인?)을 각자 해결한다.
        예를 들어 정보를 잘 정의된 인터페이스가 있는 코드 부분 안에 캡슐화 시켜서 구현하거나
        정보시스템에서 각각의 역할에 따라 계층(표현계층,비즈니스로직계층,데이터접근계층등)을 나눠서 구현하는 경우도 관심사의 분리에 해당한다.
        결과적으로 관심사의 분리를 사용하면,
        관심사를 모아 놓았기 때문에 몰입도가 높아져서 문제해결시 한가지의 목표에 보다 집중하여 해결할 수 있다.
        코드의 단순화 및 유지보수등를 진행함에 있어서 보다 편하다.

    - 응집도
        응집성은 모듈 내부의 요소들이 서로 속해 있는 정도를 의미합니다.
        클래스의 메서드 및 데이터와 해당 클래스가 제공하는 어떤 통일된 목적 또는 개념 사이의 관계 강도를 측정하는 척도입니다. 
        다른 의미로는 클래스의 메서드와 데이터 자체 간의 관계 강도를 측정하는 척도입니다.

        응집도가 높으면, 한 모듈 내부의 요소들이 모두 관계가 있으며 이는 결과적으로 한 모듈은 하나의 통일된 목적이 있기때문에 이는 모듈의 복잡도를 감소시키고 하나의 목적을 가지기 때문에 해당 목적을 필요로하는 곳에서 재사용이 용이하다.
        또한 한 모듈의 변화에 대해 적은 수정으로 대체를 할 수 있으므로 유지보수가 쉽다.

    - 결합도 Coupling (computer programming)
        소프트웨어 엔지니어링에서 커플링은 소프트웨어 모듈 간의 상호 의존성 정도, 두 루틴 또는 모듈이 얼마나 밀접하게 연결되어 있는지를 나타내는 척도로 모듈 간 관계의 강도를 의미합니다.
        높은 결합도는 모듈 간의 종속성이 증가하여 모듈을 재사용하거나 변경에 의한 파급효과가 발생한다.
        낮은 결합도은 한 모듈이 간단하고 안정적인 인터페이스를 통해 다른 모듈과 상호 작용하며 다른 모듈의 내부 구현에 신경 쓸 필요가 없는 관계를 말합니다

    - 응집도와 결합도
        응집력은 결합력과 대비되어 높은 응집력을 가지면 결합력이 느슨하고, 낮은 응집력을 가지면 결합력이 견고해진다.
        [응집도와결합도_참고자료](https://rutgo-letsgo.tistory.com/2270)

     - Layered Architecture
        기능은 웹과 분리될 수 있고 흔히 전자는 비즈니스로직이라고 부르고 후자를 UI라고 부른다. 웹은 UI Layer에서 다루고 그리고 Spring Web MVC의 Controller로 구현된다.
        기존의 Controller의 기능과 관련된 로직이 들어가있다면 해당 로직들을 발라서 Service package로 분리하여 구현 (관심사의분리를 적용한 비즈니스로직 계층)

B. Identifier
    - UUID (범용 고유 식별자,Universally Unique IDentifier) 
        소프트웨어 구축에 쓰이는 식별자 표준으로 UUID는 16 옥텟 (128비트)의 수이다. 
        표준 형식에서 UUID는 32개의 십육진수로 표현되며 총 36개 문자(32개 문자와 4개의 하이픈)로 된 8-4-4-4-12라는 5개의 그룹을 하이픈으로 구분한다.
            ex) 550e8400-e29b-41d4-a716-446655440000
        1) 자바에서 UUID사용
            자바의 경우, Class UUID를 기본적으로 제공한다.
            ex) String id = UUID.randomUUID().toString().replaceAll("-","");
        2) UUID의 단점
            128비트의 무작위성을 인코딩하는 가장 문자 효율적인 방법이 아닙니다.
            UUID v1/v2는 고유하고 안정적인 MAC 주소에 대한 액세스가 필요하기 때문에 많은 환경에서 비실용적입니다.
            UUID v3/v5는 고유한 시드가 필요하고 무작위로 분산된 ID를 생성하여 많은 데이터 구조에서 조각화를 일으킬 수 있습니다.
            UUID v4는 무작위성 외에는 다른 정보를 제공하지 않아 많은 데이터 구조에서 조각화를 일으킬 수 있습니다.
    - ULID (Universally Unique Lexicographically Sortable Identifier)
        UUID의 단점을 보완해서 나옴
        UUID는 정렬되지 않은 범용고유식별자 이지만 ULID는 정렬이 가능한 범용 고유식별자
        1) ULID의 장점
            UUID와의 128비트 호환성
            밀리초당 1.21e+24개의 고유 ULID
            사전적 정렬 가능!
            36자 UUID가 아닌 26자 문자열로 표준 인코딩됨
            효율성과 가독성을 높이기 위해 Crockford의 base32를 사용합니다(문자당 5비트).
            대소문자 구분 없음
            특수 문자 없음(URL 안전)
            단조로운 정렬 순서(동일한 밀리초를 올바르게 감지하고 처리)
            ex) 01ARZ3NDEKTSV4RRFFQ69G5FAV
        2) 자바에서 ULID사용 
            ⓐ ULID사용을 위해서는 build.gradle에 의존성 추가해야한다.
                implementation 'com.github.f4b6a3:ulid-creator:5.1.0'
            ⓑ ID 생성
                String id = UlidCreator.getUlid().toString();
    - TSID (Time-Sorted Unique Identifiers)
        시간 정렬 고유 식별자로 ULID를 개선하여 개발함
        ex) 0B433QHJFBXAC
        1) 자바에서 TSID사용
            ⓐ ULID사용을 위해서는 build.gradle에 의존성 추가해야한다.
                implementation 'com.github.f4b6a3:tsid-creator:5.2.0'
            ⓑ ID 생성
                String id = TsidCreator.getTsid().toString();

C. Refactoring
    각 기능을 개별 메서드로 분리하고, 이를 모아서 PostService 클래스로 모아주고, 다시 application 패키지로 옮긴다.
    관심사의 분리에 따라서 코드도 분리. 코드를 어떻게 배치하느냐 = 설계. 설계를 개선 = 리팩터링.
    1) Extract Function
        반복되어 사용하는 로직을 묶어서 새로운 함수를 생성하여 기존 로직에서 생성된 함수를 호출하게 하는 리팩토링 기법
    2) Extract Class
        기존의 클래스에서 필드와 메서드를 추출해서 새로운 클래스로 이동시키는 리팩토링 기법
