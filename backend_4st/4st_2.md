## 2. Data Access

- DAO(Data Access Object)
컴퓨터 소프트웨어에서 데이터 접근 객체(data access object, DAO)는 일부 종류의 데이터베이스나 기타 퍼시스턴스 매커니즘에 추상 인터페이스를 제공하는 객체이다. 응용 프로그램의 호출들을 퍼시스턴스 계층에 매핑시킴으로써 DAO는 데이터베이스의 상세한 사항을 노출시키지 않고 특정 데이터의 일부 동작을 제공하게 된다. 이러한 분리는 단일 책임 원칙을 지원한다. 도메인 특화 객체 및 자료형(DAO의 퍼블릭 인터페이스) 관점에서 응용 프로그램이 필요로 하는 데이터 접근이 무엇인지를, 어떻게 이러한 요구사항을 특정 DBMS, 데이터 스키마 등을 만족할 수 있는지(DAO의 구현체)와 분리시킨다.

디자인 패턴이 대부분의 프로그래밍 언어, 퍼시스턴스가 필요한 대부분의 소프트웨어, 대부분의 종류의 데이터베이스에 동등하게 적용되지만 전통적으로는 자바 EE 애플리케이션 및 관계형 데이터베이스와 연계된다. (해당 플랫폼에 대해 썬 마이크로시스템즈의 최고의 실천 지침[1] "코어 J2EE 패턴"에 따라 JDBC API를 통해 접근)
https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%A0%91%EA%B7%BC_%EA%B0%9D%EC%B2%B4
https://melonicedlatte.com/2021/07/24/231500.html

https://velog.io/@ohzzi/Entity-DAO-DTO%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C

https://lipcoder.tistory.com/450
https://coder-in-war.tistory.com/entry/Spring-12-DAO-DTO-Entity%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-%ED%8C%A8%ED%82%A4%EC%A7%80%EC%9D%98-%EC%A0%84%EC%B2%B4-%EA%B5%AC%EC%A1%B0

https://code-lab1.tistory.com/201
DAO
DAO(Data Access Object) 는 데이터베이스의 data에 접근하기 위한 객체입니다. DataBase에 접근 하기 위한 로직 & 비지니스 로직을 분리하기 위해 사용합니다.
DTO
DTO(Data Transfer Object) 는 계층 간 데이터 교환을 하기 위해 사용하는 객체로, DTO는 로직을 가지지 않는 순수한 데이터 객체(getter & setter 만 가진 클래스)입니다.
유저가 입력한 데이터를 DB에 넣는 과정을 보겠습니다.
유저가 자신의 브라우저에서 데이터를 입력하여 form에 있는 데이터를 DTO에 넣어서 전송합니다.
해당 DTO를 받은 서버가 DAO를 이용하여 데이터베이스로 데이터를 집어넣습니다.
VO
VO(Value Object) 값 오브젝트로써 값을 위해 쓰입니다. read-Only 특징(사용하는 도중에 변경 불가능하며 오직 읽기만 가능)을 가집니다.
DTO와 유사하지만 DTO는 setter를 가지고 있어 값이 변할 수 있습니다.

- List
List는 Memory 안의 특정한 동일 공간에 뭉텅이로 저장됩니다.

내부구현은 배열로 되어있기 때문입니다. 때문에 알맞은 데이터 저장공간만 있다면 데이터 저장속도는 빠릅니다.

또한, 순차적으로 데이터를 저장하므로, 데이터 특징이 포지션별로 의미가 있을 때 사용하는 것이 좋습니다.
기존 배열의 크기를 늘린후 삽입/삭제 데이터를 처리하고 Copy된 데이터를 다시 붙입니다. 따라서 ArrayList의 size가 큰 경우는 많은 양의 요소들을 Copy해야 하므로 내부적으로 성능이 떨어 질 수 있는 것입니다.

정리 하자면 ArrayList는 아이텝의 빈번한 변경없이, 데이터를 순차적으로 받고, 특정데이터가 아닌 원하는 데이터 범위를 순차적으로 표현할 때 유리한 자료 구조라고 볼 수 있습니다.

    리스트는 배열과 비슷한 자바의 자료형인지만 배열은 크기가 정해져있지만 리스트는 크기가 정해져있지 않고 동적으로 변한다.
    <특징>
    1) 요소의 저장 순서가 유지됩니다.
    2) 같은 요소의 중복 저장을 허용합니다. 
    <>
    1) ArrayList<E> :ArrayList 클래스는 가장 많이 사용되는 컬렉션 클래스로 내부적으로 배열을 이용하여 요소를 저장한다.
    ArrayList 클래스는 배열을 이용하기 때문에 인덱스를 이용해 배열 요소에 빠르게 접근할 수 있습니다.

    하지만 배열은 크기를 변경할 수 없는 인스턴스이므로, 크기를 늘리기 위해서는 새로운 배열을 생성하고 기존의 요소들을 옮겨야 하는 복잡한 과정을 거쳐야 합니다.

    물론 이 과정은 자동으로 수행되지만, 요소의 추가 및 삭제 작업에 걸리는 시간이 매우 길어지는 단점을 가지게 됩니다.
    2) LinkedList<E>
    LinkedList 클래스는 ArrayList 클래스가 배열을 이용하여 요소를 저장함으로써 발생하는 단점을 극복하기 위해 고안되었습니다.

JDK 1.2부터 제공된 LinkedList 클래스는 내부적으로 연결 리스트(linked list)를 이용하여 요소를 저장합니다.

 

배열은 저장된 요소가 순차적으로 저장됩니다.

하지만 연결 리스트는 저장된 요소가 비순차적으로 분포되며, 이러한 요소들 사이를 링크(link)로 연결하여 구성합니다.

다음 요소를 가리키는 참조만을 가지는 연결 리스트를 단일 연결 리스트(singly linked list)라고 합니다.

 

단일 연결 리스트

 

이러한 단일 연결 리스트는 요소의 저장과 삭제 작업이 다음 요소를 가리키는 참조만 변경하면 되므로, 아주 빠르게 처리될 수 있습니다.

하지만 단일 연결 리스트는 현재 요소에서 이전 요소로 접근하기가 매우 어렵습니다.

 

따라서 이전 요소를 가리키는 참조도 가지는 이중 연결 리스트(doubly linked list)가 좀 더 많이 사용됩니다.

 

이중 연결 리스트

 

LinkedList 클래스도 위와 같은 이중 연결 리스트를 내부적으로 구현한 것입니다.
    3) Vector<E>
 ArrayList 클래스와 같은 동작을 수행하는 클래스입니다.

현재의 Vector 클래스는 ArrayList 클래스와 마찬가지로 List 인터페이스를 상속받습니다.존 코드와의 호환성을 위해서만 남아있으므로, Vector 클래스보다는 ArrayList 클래스를 사용하는 것이 좋습니다.
    4) Stack<E>
Stack 클래스는 List 컬렉션 클래스의 Vector 클래스를 상속받아, 전형적인 스택 메모리 구조의 클래스를 제공합니다.

 

스택 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 후입선출(LIFO)의 시멘틱을 따르는 자료 구조입니다.

즉, 가장 나중에 저장된(push) 데이터가 가장 먼저 인출(pop)되는 구조입니다.

- Map
Map을 이용해 저장할때는 List처럼 뭉텅이로 저장하는 것이 아니라, Map에 아이템을 저장할때마다, 빈공간을 찾아 저장합니다.

따라서 List보다는 데이터 저장속도가 느릴 수 있습니다. Map의 가장 큰 특징이라면, 쌍을 이루는 Key와 Value값을 이용한다는 것입니다.

따라서 단순히 포지션(0~10같은 인덱션)보다는, 저장하고 싶은 데이터가 특별한 Key값을 가질 때 map을 사용하는 것이 좋습니다.
만약 동일한 Key값을 사용하면 기존의 Key값을 가지고 있는 value가 사라지고 후에 저장한 value값이 셋팅됩니다. key만 다르다면 value값이 중복되도 상관없습니다.

Map은 콘솔에 찍힌것과 같이 Key값이 의미가 있을 때 좋은 자료구조입니다.

ArrayList안에 원하는 데이터를 검색하는 경우에는 0번부터 해당데이터가 있을 때까지 검색을 해야하지만, (원하는 데이터의 index를 모르는 경우) hashMap의 경우는 key값을 통해서 빠르게 데이터를 검색합니다.

요소의 추가 삭제는 List보다 성능이 나을때가 많습니다. 따라서, 검색성능은 기본적으로 Map이 좋습니다.

정리하자면 Map은 빈번한 검색과, 범위데이터가 아닌 특정데이터를 순간마다 캐치해야할 때 유리한 자료구조 입니다.
    Map은 키(key)와 값(value)을 하나의 쌍으로 저장하는 방식으로, 순차적으로 값을 구하는 것이 아니라 key를 통해 value를 구한다.
    
    <특징>
    1) 저장 순서를 유지하지 않는다.
    2) 키는 중복으로 허용하지 않는다. (값은 중복허용가능)
    
    <사용 예시>
    Map<String,String> map1 = new HashMap<String,String>; // map 객체 생성
    map1.put("1","사과");   // insert
    map1.put("2","딸기");
    String fruit = map1.get("1");   //select
    map1.containsKey("1");   //key가 1이 존재하는 경우, true/존재하지 않으면 false
    map1.remove("2"); // key가 2인 데이터를 삭제한 후 해당 key의 value값을 return
    
    <Map 에 속하는 클래스>
    1. HashMap<K, V> : HashMap 클래스는 해시 알고리즘(hash algorithm)을 사용하여 검색 속도가 빠르다.
    2. Hashtable<K, V> : Hashtable 클래스는 JDK 1.0부터 사용해 온 HashMap 클래스와 같은 동작을 하는 클래스로 요즘은 잘 사용하지 않음.
    3. TreeMap<K, V> : TreeMap 클래스는 키와 값을 한 쌍으로 하는 데이터를 이진 검색 트리(binary search tree)의 형태로 저장한다.
    이진 검색 트리는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 빠르다. 
    JDK 1.2부터 제공된 TreeMap 클래스는 NavigableMap 인터페이스를 기존의 이진 검색 트리의 성능을 향상시킨 레드-블랙 트리(Red-Black tree)로 구현한다.


    List	수집의 순서가 있으며, 동일한 데이터의 중복 입력 가능.
ArrayList	단순이 데이터를 입력하고 데이터를 출력하는 용도로 사용
Map	Key & Value의 형태로 입력이 되며, 키값을 입력하면 해당하는 value값을 획득. 수집의 순서를 기억하지 않고, 동일한 데이터를 Key값으로 사용 할 수 없다.(동일한 Key값으로 다른 데이터의 입력 불가능)


다건의 데이터에서 원하는 특정 데이터에 접근(검색)할 때 유리한 방식
HashMap	key값으로 HashMap에 있는 데이터를 검색해서 사용하는 용도로 많이 쓰임


- 데이터를 관리하는 방법
    여러 데이터를 관리하는 방법으로 List 와 Map이 있는데 두개의 데이터 관리 방법을 골라 쓰고싶은 경우,
    PostDAO라는 인터페이스를 만들고, PostListDAO와 PostMapDAO로 구현한다(daos 패키지).


https://hahahoho5915.tistory.com/35